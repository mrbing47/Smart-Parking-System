# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EtxW8KSQZh76rQgJIzxUhveIRqWG4tA5
"""

from keras.models import Sequential
from keras.layers import *
from keras.utils import to_categorical

model = Sequential()
model.add(SimpleRNN(32, input_shape=(10,50)))
model.add(Dropout(0.4))
model.add(Dense(5))
model.add(Activation('softmax'))
model.summary()

model.compile(optimizer = 'adam', loss = 'categorical_crossentropy', metrics = ['acc'])
model.fit(xT_processed, YT, epochs = 40, validation_split = 0.1)

import keras
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout, Flatten, Conv2D, MaxPooling2D
from keras.layers.normalization import BatchNormalization
import numpy as np
np.random.seed(1000)
#Instantiate an empty model
model = Sequential()

# 1st Convolutional Layer
model.add(Conv2D(filters=16, input_shape=(224,224,3), kernel_size=(11,11), strides=(4,4), padding='valid'))
model.add(Activation('relu'))
# Max Pooling
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))

# 2nd Convolutional Layer
model.add(Conv2D(filters=20, kernel_size=(11,11), strides=(1,1), padding='valid'))
model.add(Activation('relu'))
# Max Pooling
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))
# 4th Convolutional Layer
model.add(Conv2D(filters=30, kernel_size=(3,3), strides=(1,1), padding='valid'))
model.add(Activation('relu'))

# Max Pooling
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2), padding='valid'))

# Passing it to a Fully Connected layer
model.add(Flatten())
# 1st Fully Connected Layer
model.add(Dense(48,  input_shape=(224*224*3,)))
model.add(Activation('relu'))
# Add Dropout to prevent overfitting
# model.add(Dropout(0.4))

# Output Layer
model.add(Dense(1))
model.add(Activation('softmax'))

model.summary()

# Compile the model
model.compile(loss=keras.losses.categorical_crossentropy, optimizer='adam', metrics=['accuracy'])

import cv2

train = []

for i in range(0,15000):
    img = cv2.imread('PATCHES/'+data['path'][i])
    img = cv2.resize(img, (224,224))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    train.append((img, data['label'][i]))

from keras.utils import to_categorical
y_train = to_categorical(y_train)

print(y)

from keras.models import model_from_json


json_file = open('model.json', 'r')
loaded_model_json = json_file.read()
json_file.close()
loaded_model = model_from_json(loaded_model_json)
# load weights into new model
loaded_model.load_weights("model.h5")
print("Loaded model from disk")

loaded_model.summary()

camera_1 = {
    'lot_1' : [(360, 160), (400, 199)], 
    'lot_2' : [(365, 289), (443, 366)],
    'lot_3' : [(464,347), (573, 452)],
    'lot_4' : [(111, 263), (165, 315)],
    'lot_5' : [(71, 227), (118, 273)],
    'lot_6' : [(41, 197), (79, 235)],
    'lot_7' : [(12,173), (48, 203)],
    'lot_8' : [(39, 98), (76, 134)],
}

import cv2
import numpy as np
import matplotlib.pyplot as plt

#image = cv2.imread('camera 1_1.jpg')
image = cv2.imread('2015-11-16_1710.jpg')

image = cv2.resize(image, (610, 457))
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.imshow(image)

fig=plt.figure()
columns = 4
rows = 2

images = np.zeros((8, 48, 48, 3));

for no, v in enumerate(camera_1.values()):
    x1 = v[0][0] 
    x2 = v[1][0] 
    y1 = v[0][1] 
    y2 = v[1][1] 
        
    img = np.zeros((y2 - y1, x2 - x1, 3), dtype = 'uint8')
    
    for i in range(y1, y2):
        for j in range(x1, x2):
            img[i - y1][j - x1] = image[i][j]
    
    img = cv2.resize(img, (48, 48)) / 255
    images[no] = img
    fig.add_subplot(rows, columns, no + 1)
    plt.imshow(img)
    
plt.show()

loaded_model.predict(images)

